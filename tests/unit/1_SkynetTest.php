<?php

use _support\BaseTest;
use _support\MockGuzzleClient;
use _support\MockTrait;
use Codeception\Verify\Verify;
use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use GuzzleHttp\Utils;
use http\Client\Request;
use Mockery\MockInterface;
use Psr\Http\Message\RequestInterface;
use Skynet\Skynet;
use Skynet\Types\File;
use Skynet\Uint8Array;
use function Skynet\functions\options\makeDownloadOptions;
use function Skynet\functions\options\makeHnsDownloadOptions;
use function Skynet\functions\options\makeUploadOptions;
use function Skynet\functions\strings\trimForwardSlash;
use function Skynet\functions\url\trailingslashit;
use const Skynet\DEFAULT_SKYNET_PORTAL_URL;
use const Skynet\URI_SKYNET_PREFIX;
/**
 * @group mainUnit
 */
class SkynetTest extends BaseTest {
	private string $skylinkBase32 = 'bg06v2tidkir84hg0s1s4t97jaeoaa1jse1svrad657u070c9calq4g';
	private string $entryLink = 'AQDwh1jnoZas9LaLHC_D4-2yP9XYDdZzNtz62H4Dww1jDA';
	private string $hnsLink = 'foo';
	private string $sialink = 'foo';
	private string $attachment = '?attachment=true';
	private string $expectedUrl;
	private string $expectedEntryLinkUrl;
	private string $expectedHnsUrl;
	private string $expectedHnsUrlNoSubdomain;
	private string $expectedHnsresUrl;
	private string $merkleroot = 'QAf9Q7dBSbMarLvyeE6HTQmwhr7RX9VMrP9xIMzpU3I';
	private int $bitfield = 2048;
	private array $uploadData = [];
	private string $uploadFile_url;
	private array $uploadFile_history = [];
	private string $uploadFile_filename = 'bar.txt';
	private File $uploadFile_file;
	private array $uploadDirectory_files;
	private string $uploadDirectory_url;


	private array $validSkylinkVariations;
	/**
	 * @var \Skynet\Skynet
	 */
	private array $validHnsLinkVariations;
	/**
	 * @var string[]
	 */
	private array $invalidCases;
	private array $skynetDataHeaders;
	/**
	 * @var string[]
	 */
	private array $skynetFileMetadata;
	private array $skynetFileContentHeaders;
	/**
	 * @var string[]
	 */
	private array $skynetFileContents;

	private string $expectedPinUrl;

	public static function assertEqualsIgnoringCase( $expected, $actual, string $message = '' ): void {
		parent::assertEqualsIgnoringCase( $expected, $actual, $message ); // TODO: Change the autogenerated stub
	}

	public function _before() {
		parent::_before();
		$this->sialink                   = URI_SKYNET_PREFIX . $this->skylink;
		$this->expectedUrl               = "{$this->portalUrl}/{$this->skylink}";
		$this->expectedEntryLinkUrl      = "{$this->portalUrl}/{$this->entryLink}";
		$this->expectedHnsUrl            = "https://{$this->hnsLink}.hns.siasky.net/";
		$this->expectedHnsUrlNoSubdomain = "{$this->portalUrl}/hns/{$this->hnsLink}";
		$this->expectedHnsresUrl         = "{$this->portalUrl}/hnsres/{$this->hnsLink}";
		$this->expectedBase32            = "https://{$this->skylinkBase32}.siasky.net/";
		$this->invalidCases              = [
			'123',
			"{$this->skylink}xxx",
			"{$this->skylink}xxx/foo",
			"{$this->skylink}xxx?foo",
		];

		$this->validSkylinkVariations =
			combineStrings(
				[
					'',
					'sia:',
					'sia://',
					'https://siasky.net/',
					'https://foo.siasky.net/',
					"https://{$this->skylinkBase32}.siasky.net/",
				],
				[ $this->skylink ],
				[ '', '/', '//', '/foo', '/foo/', '/foo/bar', '/foo/bar/', '/foo/bar//' ],
				[ '', '?', '?foo=bar', '?foo=bar&bar=baz' ],
				[ '', '#', '#foo', '#foo?bar' ]
			);
		$this->validHnsLinkVariations = [ $this->hnsLink, "hns:{$this->hnsLink}", "hns://{$this->hnsLink}" ];

		$this->skynetDataHeaders        = [
			'skynet-portal-api' => $this->portalUrl,
			'skynet-skylink'    => $this->skylink,
		];
		$this->skynetFileMetadata       = [ 'filename' => 'sia.pdf' ];
		$this->skynetFileContents       = [ 'arbitrary' => 'json string' ];
		$this->skynetFileContentHeaders = [
			'skynet-portal-api' => $this->portalUrl,
			'skynet-skylink'    => $this->skylink,
			'content-type'      => 'application/json',
		];
		$this->expectedPinUrl           = "{$this->portalUrl}/skynet/pin/{$this->skylink}";
		$this->uploadData               = [
			'skylink'    => $this->skylink,
			'merkleroot' => $this->merkleroot,
			'bitfield'   => $this->bitfield,
		];
		$this->uploadFile_url           = $this->portalUrl . '/skynet/skyfile';
		$this->uploadFile_file          = new File( [
			'data'     => Uint8Array::from( 'foo' ),
			'fileName' => $this->uploadFile_filename,
			'mime'     => 'text/plain',
		] );

		$this->uploadDirectory_files = [
			new File( [ 'data' => Uint8Array::from( 'foo1' ), 'fileName' => 'file1.jpeg', 'filePath' => 'i-am-not' ] ),
			new File( [
				'data'     => Uint8Array::from( 'foo2' ),
				'fileName' => 'i-am-not/file2.jpeg',
				'filePath' => 'i-am-not',
			] ),
			new File( [
				'data'     => Uint8Array::from( 'foo3' ),
				'fileName' => 'i-am-not/me-neither/file3.jpeg',
				'filePath' => 'i-am-not/me-neither',
			] ),
		];
		$this->uploadDirectory_url   = "{$this->portalUrl}/skynet/skyfile";
	}

	public function testSkynet_ShouldNotMakeAPortalUrlRequestIfPortalUrlIsGiven() {
		$this->client->getPortalUrl();
		$this->requestsMock->shouldNotHaveReceived( 'request' );
	}

	public function testBuildRequestUrl_ShouldBuildAUrlFromTheGivenComponents() {
		$endpointPath = "/skynet/foo";
		$extraPath    = "bar";
		$query        = [ 'foo' => 'bar' ];
		$expectedUrl  = "{$this->portalUrl}/skynet/foo/bar?foo=bar";

		$url = $this->client->buildRequestUrl( $endpointPath, null, $extraPath, $query );
		expect( $url )->toEqual( $expectedUrl );
	}

	public function testDownloadFile_ShouldDownloadWithAttachmentSetFromSkylink() {
		$this->_beforeDownloadTest();
		foreach ( $this->validSkylinkVariations as $fullSkylink ) {
			$url  = $this->client->downloadFile( $fullSkylink );
			$path = extractNonSkylinkPath( $fullSkylink, $this->skylink );

			$fullExpectedUrl = $this->expectedUrl . $path . $this->attachment;
			expect( $url->getBody()->getContents() )->toEqual( $fullExpectedUrl );
		}
	}

	private function _beforeDownloadTest() {
		//$this->getRequestMock()->andReturn( $this->buildRequestResponse( 200, $this->skynetFileMetadata, $this->skynetDataHeaders ) );
		return $this->getRequestMock( function ( ...$args ) {
			$this->requestsArgs = $args;

			return true;
		} )->andReturnUsing( function ( ...$args ) {
			return new Response( 200, [], $args[1] );
		} )->atLeast()->once();
		//	$this->getRequestMockSucessfulReturnCaptureArgs( [], $this->skynetDataHeaders );
		/*		$this->getRequestMock()->andReturnUsing( function ( $url ) {
					return new Response(200, [], $url);
				});*/
	}

	public function testDownloadFile_ShouldDownloadWithTheOptionalPathBeingCorrectlyUriencoded() {
		$this->_beforeDownloadTest();
		$url = $this->client->downloadFile( $this->skylink, makeDownloadOptions( [ 'path' => 'dir/test?encoding' ] ) );
		expect( $url->getBody()->getContents() )->toEqual( "{$this->expectedUrl}/dir/test%3Fencoding{$this->attachment}" );

	}

	public function testDownloadFileHns_ShouldDownloadWithTheCorrectLinkUsingHnsLink() {
		$this->_beforeDownloadTest();
		foreach ( $this->validHnsLinkVariations as $input ) {
			$url = $this->client->downloadFileHns( $input );
			expect( $url->getBody()->getContents() )->toEqual( $this->expectedHnsUrl . $this->attachment );
		}
	}

	public function testGetHnsUrl_ShouldReturnCorrectlyFormedNonsubdomainHnsUrlUsingHnsLink() {
		foreach ( $this->validHnsLinkVariations as $input ) {
			expect( $this->client->getHnsUrl( $input ) )->toEqual( $this->expectedHnsUrl );
			expect( $this->client->getHnsUrl( $input, makeHnsDownloadOptions( [ 'subdomain' => false ] ) ) )->toEqual( $this->expectedHnsUrlNoSubdomain );
		}
	}

	public function testGetHnsUrl_ShouldReturnCorrectlyFormedHnsUrlWithForcedDownload() {
		$url = $this->client->getHnsUrl( $this->hnsLink, makeHnsDownloadOptions( [ 'download' => true ] ) );
		expect( $url )->toEqual( $this->expectedHnsUrl . $this->attachment );
	}

	public function testGetHnsresUrl_ShouldReturnCorrectlyFormedHnsresUrlUsingHnsresLink() {
		foreach ( $this->validHnsLinkVariations as $input ) {
			expect( $this->client->getHnsresUrl( $input ) )->toEqual( $this->expectedHnsresUrl );
		}
	}

	public function testGetSkylinkUrl_ShouldReturnCorrectlyFormedSkylinkUrlUsingSkylink() {
		foreach ( $this->validSkylinkVariations as $fullSkylink ) {
			$path = extractNonSkylinkPath( $fullSkylink, $this->skylink );

			$expectedPathUrl = $this->expectedUrl;
			if ( '' !== $path ) {
				$expectedPathUrl = $this->expectedUrl . $path;
			}

			expect( $this->client->getSkylinkUrl( $fullSkylink ) )->toEqual( $expectedPathUrl );
		}
	}

	public function testGetSkylinkUrl_ShouldReturnCorrectlyFormedUrlsWhenPathIsGiven() {
		expect( $this->client->getSkylinkUrl( $this->skylink, makeDownloadOptions( [ "path" => 'foo/bar' ] ) ) )->toEqual( "{$this->expectedUrl}/foo/bar" );
		expect( $this->client->getSkylinkUrl( $this->skylink, makeDownloadOptions( [ "path" => 'foo?bar' ] ) ) )->toEqual( "{$this->expectedUrl}/foo%3Fbar" );
	}

	public function testGetSkylinkUrl_ShouldReturnCorrectlyFormedUrlWithForcedDownload() {
		$url = $this->client->getSkylinkUrl( $this->skylink, makeDownloadOptions(
			[
				'download'         => true,
				'endpointDownload' => 'skynet/skylink',
			] ) );

		expect( $url )->toEqual( "{$this->portalUrl}/skynet/skylink/{$this->skylink}{$this->attachment}" );
	}

	public function testGetSkylinkUrl_ShouldReturnCorrectlyFormedUrlsWithForcedDownloadAndPath() {
		$url = $this->client->getSkylinkUrl( $this->skylink, makeDownloadOptions(
			[
				'download' => true,
				'path'     => 'foo?bar',
			] ) );

		expect( $url )->toEqual( "{$this->expectedUrl}/foo%3Fbar{$this->attachment}" );
	}

	public function testGetSkylinkUrl_ShouldConvertBase64SkylinkToBase32UsingSkylink() {
		foreach ( $this->validSkylinkVariations as $fullSkylink ) {
			$path = extractNonSkylinkPath( $fullSkylink, $this->skylink );
			$path = trimForwardSlash( $path );
			$url  = $this->client->getSkylinkUrl( $fullSkylink, makeDownloadOptions(
				[
					'subdomain' => true,
				] ) );
			expect( $url )->toEqual( "{$this->expectedBase32}{$path}" );
		}
	}

	public function testGetSkylinkUrl_ShouldThrowIfPassingANonstringPath() {
		Verify::Callable( function () {
			$this->client->getSkylinkUrl( $this->skylink, makeDownloadOptions(
				[
					'path' => true,
				] ) );
		} )->throws( Exception::class, '$options->path has to be a string, bool provided' );
	}

	public function testGetSkylinkUrl_ShouldThrowOnInvalidSkylink() {
		foreach ( $this->invalidCases as $invalidSkylink ) {
			Verify::Callable( function () use ( $invalidSkylink ) {
				$this->client->getSkylinkUrl( $invalidSkylink );
			} )->throws();
			Verify::Callable( function () use ( $invalidSkylink ) {
				$this->client->getSkylinkUrl( $invalidSkylink, makeDownloadOptions(
					[
						'subdomain' => true,
					] ) );
			} )->throws();
		}
	}

	public function testGetMetadata_ShouldSuccessfullyFetchSkynetFileMetadataFromSkylink() {

		$this->getRequestMock()->andReturn( $this->buildRequestResponse( 200, $this->skynetFileMetadata, $this->skynetDataHeaders ) );
		/** @var \Skynet\Types\GetMetadataResponse $metaData */
		[ 'metadata' => $metaData ] = $this->client->getMetadata( $this->skylink );

		expect( $metaData )->toEqual( (object) [ 'filename' => 'sia.pdf' ] );
	}

	/** @noinspection PhpOptionalBeforeRequiredParametersInspection */

	public function testGetMetadata_ShouldThrowIfAPathIsSupplied() {
		Verify::Callable( function () {
			$this->client->getMetadata( "{$this->skylink}/path/file" );
		} )->throws( Exception::class, 'Skylink string should not contain a path' );
	}

	public function testGetMetadata_ShouldThrowIfNoDataWasReturnedToGetMetadata() {
		$this->getRequestMockSucessfulReturn( null, $this->skynetDataHeaders );

		Verify::Callable( function () {
			$this->client->getMetadata( $this->skylink );
		} )->throws( Exception::class, 'Metadata response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'response->body\' field missing' );
	}

	public function testGetMetadata_ShouldThrowIfNoHeadersWereReturned() {
		$this->getRequestMockSucessfulReturn();

		Verify::Callable( function () {
			$this->client->getMetadata( $this->skylink );
		} )->throws( Exception::class, 'Metadata response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'response->headers\' field missing' );

	}

	public function testGetMetadata_ShouldThrowIfSkynetportalapiHeaderIsMissing() {
		$incompleteHeaders = $this->skynetDataHeaders;
		unset( $incompleteHeaders['skynet-portal-api'] );

		$this->getRequestMockSucessfulReturn( [], $incompleteHeaders );

		Verify::Callable( function () {
			$this->client->getMetadata( $this->skylink );
		} )->throws( Exception::class, 'Metadata response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'skynet-portal-api\' header missing' );
	}

	public function testGetMetadata_ShouldThrowIfSkynetskylinkHeaderIsMissing() {
		$incompleteHeaders = $this->skynetDataHeaders;
		unset( $incompleteHeaders['skynet-skylink'] );

		$this->getRequestMockSucessfulReturn( [], $incompleteHeaders );

		Verify::Callable( function () {
			$this->client->getMetadata( $this->skylink );
		} )->throws( Exception::class, 'Metadata response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'skynet-skylink\' header missing' );
	}

	public function testGetFileContent_ShouldSuccessfullyFetchSkynetFileContent() {
		foreach ( $this->validSkylinkVariations as $input ) {
			$skylinkUrl = $this->client->getSkylinkUrl( $input );
			$this->getRequestMockSucessfulReturn( $this->skynetFileContents, $this->skynetFileContentHeaders, [ $skylinkUrl ] );
			[
				'data'        => $data,
				'contentType' => $contentType,
				'skylink'     => $skylink2,
			] = $this->client->getFileContent( $input );

			expect( json_decode( $data ) )->toEqual( (object) $this->skynetFileContents );
			expect( $contentType )->toEqual( 'application/json' );
			expect( $skylink2 )->toEqual( $this->sialink );
		}
	}

/*	public function testGetFileContent_ShouldThrowIfDataIsNotReturned() {
		$this->getRequestMockSucessfulReturn( null, [], [ "{$this->portalUrl}/{$this->skylink}" ] );
		Verify::Callable( function () {
			$this->client->getFileContent( $this->skylink );
		} )->throws( Exception::class, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'response->data\' field missing' );
	}*/

	public function testGetFileContent_ShouldThrowIfNoHeadersAreReturned() {
		$this->getRequestMockSucessfulReturn( [], [], [ "{$this->portalUrl}/{$this->skylink}" ] );
		Verify::Callable( function () {
			$this->client->getFileContent( $this->skylink );
		} )->throws( Exception::class, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'response->headers\' field missing' );
	}

	public function testGetFileContent_ShouldThrowIfContenttypeHeaderIsMissing() {
		$incompleteHeaders = $this->skynetFileContentHeaders;
		unset( $incompleteHeaders['content-type'] );
		$this->getRequestMockSucessfulReturn( [], $incompleteHeaders, [ "{$this->portalUrl}/{$this->skylink}" ] );
		Verify::Callable( function () {
			$this->client->getFileContent( $this->skylink );
		} )->throws( Exception::class, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. \'content-type\' header missing' );
	}

	public function testGetFileContent_ShouldSetRangeHeaderIfRangeOptionIsSet() {
		$range = '4000-5000';
		$this->getRequestMockSucessfulReturnCaptureArgs( $this->skynetFileContents, $this->skynetFileContentHeaders );
		$this->client->getFileContent( $this->skylink, makeDownloadOptions( [ 'range' => $range, ] ) );
		expect( $this->requestsArgs[2]['headers'] )->toEqual( [ 'range' => $range ] );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfSkynetproofHeaderIsNotValidJson() {
		$this->_testGetFileContent_ProofValidation( [ 'skynet-proof' => 'foo' ], false, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Could not parse \'skynet-proof\' header as JSON' );
	}

	private function _testGetFileContent_ProofValidation( array $headers, $link = null, string $error ) {
		$headersWithProof = array_merge( $this->skynetFileContentHeaders, $headers );

		$this->getRequestMockSucessfulReturnCaptureArgs( [], $headersWithProof );

		if ( null !== $link ) {
			if ( is_bool( $link ) ) {
				$link = $link ? $this->entryLink : $this->skylink;
			}
		}

		Verify::Callable( function () use ( $link ) {
			$this->client->getFileContent( $link );
		} )->throws( Exception::class, $error );

	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfSkynetProofHeaderIsNull() {
		$this->_testGetFileContent_ProofValidation( [ 'skynet-proof' => 'null' ], false, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Could not parse \'skynet-proof\' header as JSON' );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfProofIsPresentForDataLink() {
		$this->_testGetFileContent_ProofValidation( [ 'skynet-proof' => '[1, 2]' ], false, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Expected \'skynet-proof\' header to be empty for data link' );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfSkynetskylinkDoesNotMatchInputDataLink() {
		$this->_testGetFileContent_ProofValidation( [
			'skynet-proof'   => '[]',
			'skynet-skylink' => $this->entryLink,
		], false, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Expected returned skylink to be the same as input data link' );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfSkynetskylinkMatchesInputEntryLink() {
		$this->_testGetFileContent_ProofValidation( [
			'skynet-proof'   => '[]',
			'skynet-skylink' => $this->entryLink,
		], $this->expectedEntryLinkUrl, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Expected returned skylink to be different from input entry link' );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfProofIsEmptyForEntryLink() {
		$this->_testGetFileContent_ProofValidation( [ 'skynet-proof' => '[]' ], $this->expectedEntryLinkUrl, 'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Expected registry proof not to be empty' );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfProofContainsUnsupportedRegistryType() {
		$this->_testGetFileContent_ProofValidation(
			[
				'skynet-proof' => '[{"data":"5c006f8bb26d25b412300703c275279a9d852833e383cfed4d314fe01c0c4b155d12","revision":0,"datakey":"43c8a9b01609544ab152dad397afc3b56c1518eb546750dbc6cad5944fec0292","publickey":{"algorithm":"ed25519","key":"y/l99FyfFm6JPhZL5xSkruhA06Qh9m5S9rnipQCc+rw="},"signature":"5a1437508eedb6f5352d7f744693908a91bb05c01370ce4743de9c25f761b4e87760b8172448c073a4ddd9d58d1a2bf978b3227e57e4fa8cbe830a2353be2207","type":0}]',
			],
			$this->expectedEntryLinkUrl,
			'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Unsupported registry type in proof: \'0\''
		);
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfProofChainIsInvalid() {
		$newSkylink = str_replace( '-', '_', $this->entryLink );
		$this->_testGetFileContent_ProofValidation(
			[
				'skynet-proof' => '[{"data":"5c006f8bb26d25b412300703c275279a9d852833e383cfed4d314fe01c0c4b155d12","revision":0,"datakey":"43c8a9b01609544ab152dad397afc3b56c1518eb546750dbc6cad5944fec0292","publickey":{"algorithm":"ed25519","key":"y/l99FyfFm6JPhZL5xSkruhA06Qh9m5S9rnipQCc+rw="},"signature":"5a1437508eedb6f5352d7f744693908a91bb05c01370ce4743de9c25f761b4e87760b8172448c073a4ddd9d58d1a2bf978b3227e57e4fa8cbe830a2353be2207","type":1}]',
			],
			$newSkylink,
			'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Could not verify registry proof chain'
		);
		expect( $this->requestsArgs[1] )->toEqual( "{$this->portalUrl}/{$newSkylink}" );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfSignatureIsInvalid() {
		$this->_testGetFileContent_ProofValidation(
			[
				'skynet-proof' => '[{"data":"5c006f8bb26d25b412300703c275279a9d852833e383cfed4d314fe01c0c4b155d12","revision":0,"datakey":"43c8a9b01609544ab152dad397afc3b56c1518eb546750dbc6cad5944fec0292","publickey":{"algorithm":"ed25519","key":"y/l99FyfFm6JPhZL5xSkruhA06Qh9m5S9rnipQCc+rw="},"signature":"4a1437508eedb6f5352d7f744693908a91bb05c01370ce4743de9c25f761b4e87760b8172448c073a4ddd9d58d1a2bf978b3227e57e4fa8cbe830a2353be2207","type":1}]',
			],
			true,
			'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Could not verify signature from retrieved, signed registry entry in registry proof'
		);
		expect( $this->requestsArgs[1] )->toEqual( $this->expectedEntryLinkUrl );
	}

	public function testGetFileContent_ProofValidation_ShouldThrowIfProofChainResultsInDifferentDataLink() {
		$dataLink = 'EAAFgq17B-MKsi0ARYKUMmf9vxbZlDpZkA6EaVBCG4YBAQ';
		$this->_testGetFileContent_ProofValidation(
			[
				'skynet-proof'   => '[{"data":"5c006f8bb26d25b412300703c275279a9d852833e383cfed4d314fe01c0c4b155d12","revision":0,"datakey":"43c8a9b01609544ab152dad397afc3b56c1518eb546750dbc6cad5944fec0292","publickey":{"algorithm":"ed25519","key":"y/l99FyfFm6JPhZL5xSkruhA06Qh9m5S9rnipQCc+rw="},"signature":"5a1437508eedb6f5352d7f744693908a91bb05c01370ce4743de9c25f761b4e87760b8172448c073a4ddd9d58d1a2bf978b3227e57e4fa8cbe830a2353be2207","type":1}]',
				'skynet-skylink' => $dataLink,
			],
			true,
			'File content response invalid despite a successful request. Please try again and report this issue to the devs if it persists. Could not verify registry proof chain'
		);
		expect( $this->requestsArgs[1] )->toEqual( $this->expectedEntryLinkUrl );
	}

	public function testGetFileContentHns_ShouldSuccessfullyFetchSkynetFileContentForDomain() {
		foreach ( $this->validHnsLinkVariations as $domain ) {
			$hnsUrl    = $this->client->getHnsUrl( $domain );
			$hnsresUrl = $this->client->getHnsresUrl( $domain );

			$this->getRequestMockSucessfulReturn( $this->skynetFileContents, $this->skynetFileContentHeaders, [ $hnsUrl ] );
			$this->getRequestMockSucessfulReturn( [ 'skylink' => $this->skylink ], $this->skynetFileContentHeaders, [ $hnsresUrl ] );

			[ 'data' => $data ] = $this->client->getFileContentHns( $domain );

			expect( json_decode( $data, true ) )->toEqual( $this->skynetFileContents );
		}
	}

	public function testDownloadFileHns_ShouldSetDomainWithThePortalAndHnsLinkAndThenDownloadWithAttachmentSet() {
		foreach ( $this->validHnsLinkVariations as $input ) {
			$fullInput = "{$this->expectedHnsUrl}?attachment=true";
			$this->getRequestMockSucessfulReturnCaptureArgs( [], [], 'get' );
			$this->client->downloadFileHns( $input );
			expect( $this->requestsArgs[1] )->stringToContainString( $fullInput );
		}
	}

	public function testResolveHns_ShouldCallAxiosgetWithThePortalAndHnsresLinkForXAndReturnTheJsonBody() {
		foreach ( $this->validHnsLinkVariations as $hnsLink ) {
			$this->getRequestMockSucessfulReturnCaptureArgs( [ 'skylink' => $this->skylink ], [ 'skynet-portal-api' => $this->portalUrl ] );
			$data = $this->client->resolveHns( $hnsLink );

			expect( $data->getSkylink() )->toEqual( $this->skylink );
		}
	}

	public function testResolveHns_ShouldThrowIfUnexpectedDataWasReturnedToResolveHns() {
		$this->getRequestMockSucessfulReturn( [ 'foo' => 'foo' ], [], [ $this->expectedHnsresUrl ] );
		Verify::Callable( function () {
			$this->client->resolveHns( $this->hnsLink );
		} )->throws( Exception::class, "Did not get a complete resolve HNS response despite a successful request. Please try again and report this issue to the devs if it persists. Expected 'response body object', 'response->body', to be object containing skylink or registry field, was type 'object', value (object) array(
   'foo' => 'foo',
)" );
	}

	public function testGetFileContent_ShouldPinTheSkylinkUsingTheCorrectUrl() {
		$this->getRequestMockSucessfulReturn( [], [
			'skynet-portal-api' => $this->portalUrl,
			'skynet-skylink'    => $this->skylink,
		], [ $this->expectedPinUrl ] );
		[ 'skylink' => $skylink2 ] = $this->client->pinSkylink( $this->skylink );

		expect( $skylink2 )->toEqual( $this->sialink );
	}

	public function testGetFileContent_ShouldThrowIfAPathIsSupplied() {
		Verify::Callable( function () {
			$this->client->pinSkylink( "{$this->skylink}/path/file" );
		} )->throws( Exception::class, 'Skylink string should not contain a path' );
	}

	public function testGetFileContent_ShouldThrowIfASkylinkWasNotReturned() {
		$this->getRequestMockSucessfulReturn( [], [
			'skynet-portal-api' => $this->portalUrl,
		], [ $this->expectedPinUrl ] );
		Verify::Callable( function () {
			$this->client->pinSkylink( $this->skylink );
		} )->throws( Exception::class, "Did not get a complete pin response despite a successful request. Please try again and report this issue to the devs if it persists. Expected 'pin response field', 'response->headers(\"skynet-skylink\")', to be type 'string', was type 'null'" );
	}

	public function testGetFileContent_ShouldThrowIfNoDataWasReturnedToPinskylink() {
		$this->getRequestMockSucessfulReturn( [], [], [ $this->expectedPinUrl ] );
		Verify::Callable( function () {
			$this->client->pinSkylink( $this->skylink );
		} )->throws( Exception::class, 'Did not get a complete pin response despite a successful request. Please try again and report this issue to the devs if it persists. response->headers field missing' );
	}

	public function testUploadFile_ShouldSendFormdataWithFile() {
		$this->_before_uploadFile();
		$result = $this->client->uploadFile( $this->uploadFile_file );
		expect( count( $this->uploadFile_history ) )->toEqual( 1 );
		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$requestOptions = $this->client->getHttpClient()->getLastRequest();

		$data = json_decode( $response->getBody()->getContents() );

		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $result->getSkylink() )->toEqual( $this->sialink );
		expect( $requestOptions['multipart'][0]['filename'] )->toEqual( $this->uploadFile_file->getFileName() );
		expect( $requestOptions['multipart'][0]['contents'] )->toEqual( $this->uploadFile_file->getData() );
	}

	private function _before_uploadFile() {
		$this->uploadFile_history = [];
		$mock                     = new MockHandler( [
			new Response( 200, [], json_encode( $this->uploadData ) ),
			//		new Response( 200, [ 'skynet-portal-api' => $this->portalUrl ] ),
		] );
		$handlerStack             = HandlerStack::create( $mock );
		$handlerStack->push( Middleware::history( $this->uploadFile_history ) );
		/*		$handlerStack->push( function ( callable $handler ): callable {
					return function ( RequestInterface $request, array $options ) use ( $handler ) {
						if ( $request->getUri() === $this->portalUrl ) {
							return $handler(new Response( 200, [ 'skynet-portal-api' => $this->portalUrl ] ));
						}

						return $handler(new Response( 200, [], json_encode( $this->uploadData ) ));
					};
				} );*/
		$this->client->setHttpClient( new MockGuzzleClient( [ 'handler' => $handlerStack ] ) );
	}

	public function testUploadFile_ShouldUseCustomFilenameIfProvided() {
		$customFilename = 'testname';
		$this->_before_uploadFile();
		$result = $this->client->uploadFile( $this->uploadFile_file, makeUploadOptions( [ 'customFilename' => $customFilename ] ) );
		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$requestOptions = $this->client->getHttpClient()->getLastRequest();

		$data = json_decode( $response->getBody()->getContents() );

		expect( $requestOptions['multipart'][0]['filename'] )->toEqual( $customFilename );
		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $result->getSkylink() )->toEqual( $this->sialink );

	}

	public function testUploadFile_ShouldSendBase64AuthenticationPasswordIfProvided() {
		$this->_before_uploadFile();
		$result = $this->client->uploadFile( $this->uploadFile_file, makeUploadOptions( [ 'apiKey' => 'foobar' ] ) );
		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$requestOptions = $this->client->getHttpClient()->getLastRequest();

		$data = json_decode( $response->getBody()->getContents() );

		expect( $requestOptions['auth'][0] )->toBeEmpty();
		expect( $requestOptions['auth'][1] )->toEqual( 'foobar' );
		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $result->getSkylink() )->toEqual( $this->sialink );
	}

	public function testUploadFile_ShouldSendPortalsCustomUserAgentAndCookieIfDefined() {
		$this->_before_uploadFile();
		$result = $this->client->uploadFile( $this->uploadFile_file, makeUploadOptions( [
			'customUserAgent' => 'Sia-Agent',
			'customCookie'    => 'foo',
		] ) );
		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$requestOptions = $this->client->getHttpClient()->getLastRequest();

		$data = json_decode( $response->getBody()->getContents() );

		expect( $requestOptions['headers']['User-Agent'] )->toEqual( 'Sia-Agent' );
		expect( $requestOptions['headers']['Cookie'] )->toEqual( 'foo' );
		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $result->getSkylink() )->toEqual( $this->sialink );
	}

	public function testUploadFile_ShouldThrowIfASkylinkWasNotReturned() {
		$this->uploadFile_history = [];
		$mock                     = new MockHandler( [
			new Response( 200, [], json_encode( [] ) ),
		] );
		$handlerStack             = HandlerStack::create( $mock );
		$handlerStack->push( Middleware::history( $this->uploadFile_history ) );
		$this->client->setHttpClient( new MockGuzzleClient( [ 'handler' => $handlerStack ] ) );
		Verify::Callable( function () {
			$this->client->uploadFile( $this->uploadFile_file );
		} )->throws( Exception::class, "Did not get a complete upload response despite a successful request. Please try again and report this issue to the devs if it persists. Expected 'upload response field', 'skylink', to be type 'string', was type 'null'" );
	}


	public function testUploadFile_ShouldThrowIfNoDataWasReturnedToUploadfile() {
		$this->uploadFile_history = [];
		$mock                     = new MockHandler( [
			new Response( 200, [] ),
		] );
		$handlerStack             = HandlerStack::create( $mock );
		$handlerStack->push( Middleware::history( $this->uploadFile_history ) );
		$this->client->setHttpClient( new MockGuzzleClient( [ 'handler' => $handlerStack ] ) );
		Verify::Callable( function () {
			$this->client->uploadFile( $this->uploadFile_file );
		} )->throws( Exception::class, "Did not get a complete upload response despite a successful request. Please try again and report this issue to the devs if it persists. response->body field missing" );
	}

	public function testuploadDirectory_ShouldSendFormdataWithFiles() {
		$this->_before_uploadFile();

		$this->client->uploadDirectory( $this->uploadDirectory_files, 'i-am-root' );

		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$requestOptions = $this->client->getHttpClient()->getLastRequest();

		$data = json_decode( $response->getBody()->getContents() );
		expect( $data->skylink )->toEqual( $this->skylink );

		foreach ( $this->uploadDirectory_files as $index => $file ) {
			expect( $requestOptions['multipart'][ $index ]['name'] )->toEqual( 'files[]' );
			expect( $requestOptions['multipart'][ $index ]['contents'] )->toEqual( $file->getData() );
			expect( $requestOptions['multipart'][ $index ]['filename'] )->toEqual( trailingslashit( $file->getFilePath() ) . $file->getFileName() );
		}
	}

	public function testuploadDirectory_ShouldSendErrorpagesIfGiven() {
		$this->_before_uploadFile();

		$this->client->uploadDirectory( $this->uploadDirectory_files, 'i-am-root', makeUploadOptions( [
			'errorPages' => [
				404 => '404.html',
				500 => '500.html',
			],
		] ) );

		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$query = 'filename=i-am-root&errorpages=%7B%22404%22%3A%22404.html%22%2C%22500%22%3A%22500.html%22%7D';

		$data = json_decode( $response->getBody()->getContents() );
		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $request['request']->getUri()->getQuery() )->toEqual( $query );
	}

	public function testuploadDirectory_ShouldSendTryfilesIfGiven() {
		$this->_before_uploadFile();

		$this->client->uploadDirectory( $this->uploadDirectory_files, 'i-am-root', makeUploadOptions( [
			'tryFiles' => [ 'foo', 'bar' ],
		] ) );

		expect( count( $this->uploadFile_history ) )->toEqual( 1 );

		$request  = $this->uploadFile_history[0];
		$response = $request['response'];
		$response->getBody()->rewind();
		$query = 'filename=i-am-root&tryfiles=%5B%22foo%22%2C%22bar%22%5D';

		$data = json_decode( $response->getBody()->getContents() );
		expect( $data->skylink )->toEqual( $this->skylink );
		expect( $request['request']->getUri()->getQuery() )->toEqual( $query );
	}

	public function testUploadDirectory_ShouldThrowIfASkylinkWasNotReturned() {
		$this->uploadFile_history = [];
		$mock                     = new MockHandler( [
			new Response( 200, [] ),
		] );
		$handlerStack             = HandlerStack::create( $mock );
		$handlerStack->push( Middleware::history( $this->uploadFile_history ) );
		$this->client->setHttpClient( new MockGuzzleClient( [ 'handler' => $handlerStack ] ) );
		Verify::Callable( function () {
			$this->client->uploadDirectory( $this->uploadDirectory_files, 'i-am-root' );
		} )->throws( Exception::class, "Did not get a complete upload response despite a successful request. Please try again and report this issue to the devs if it persists. response->body field missing" );
	}


	public function testSetPortalLogin_CanWeSuccessfullyLogIn() {
		if ( ( $email = getenv( 'PORTAL_LOGIN_EMAIL' ) ) && ( $password = getenv( 'PORTAL_LOGIN_PASSWORD' ) ) ) {
			$this->client->setHttpClient( new Client() );
			Verify::Callable( function () use ( $password, $email ) {
				$this->client->setPortalLogin( $email, $password );
			} )->doesNotThrow();
		}
	}
}
